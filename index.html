<!DOCTYPE html>
<html lang="en">
  <head>
    <title>AR Image Placement with Logging</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <link rel="stylesheet" href="./css/index.css" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
        }
      }
    </script>
    <style>
      /* Styling for the log messages */
      #log-container {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 8px;
        font-family: Arial, sans-serif;
        font-size: 14px;
        max-width: 80%;
        z-index: 1000;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div class="bg"></div>
    <div class="main-container">
      <div class="header">
        <div id="AR-title" class="AR-title"></div>
        <div class="ar-exp"></div>
      </div>
      <div id="middle-part" class="middle-part page-2-middle-part">
        <div class="steps">
          <p>For the best AR viewing experience, follow these steps:</p>
        </div>
        <div class="image"></div>
        <div class="steps2">
          <p>Stand at the center of your living room with 4 feet of empty space.</p>
          <p>Point the camera at a flat surface and scan it when prompted.</p>
          <p>Enjoy your AR image!</p>
        </div>
      </div>
    </div>

    <div id="overlay">
      <div id="log-container">Initializing AR...</div>
      <div id="look_for_surface_icon"></div>
	  <div id="close_ar_button"></div>
      <div id="footer" class="footer footer-2"></div>
    </div>

    <script type="module">
      import * as THREE from "three";
      import { ARButton } from "three/addons/webxr/ARButton.js";

      let camera, scene, renderer;
      let controller;
      let xrReferenceSpace = null;
      let reticle = null;
      let hitSomething = false;
      let imageMesh = null;

      let isXRSessionStarted = false;
	  const look_for_surface_icon = document.getElementById("look_for_surface_icon");
      let logContainer = document.getElementById("log-container");
      var close_ar_button = document.getElementById("close_ar_button");

      // Reload page or stop AR when clicking the close button
      close_ar_button.addEventListener("click", () => {
        if (renderer.xr.isPresenting) {
          renderer.xr.getSession().end();
        } else {
          location.reload();
        }
      });

      if (navigator.xr) {
        navigator.xr.isSessionSupported("immersive-ar").then((isSupported) => {
          if (!isSupported) {
            const btn = document.getElementById("ARButton");
            btn.addEventListener("click", () => {
              window.location.href = "/qr";
            });
          }
        });
      }

      init();
      animate();

      function init() {
        const container = document.createElement("div");
        document.body.appendChild(container);

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.01,
          20
        );

        const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        container.appendChild(renderer.domElement);

        document.getElementById("middle-part").appendChild(
          ARButton.createButton(renderer, {
            requiredFeatures: ["local", "hit-test"],
            optionalFeatures: ["dom-overlay"],
            domOverlay: { root: document.getElementById("overlay") },
          })
        );

        controller = renderer.xr.getController(0);
        controller.addEventListener("select", onSelect);
        scene.add(controller);

        logStatus("AR Session Started");

        addReticleToScene();
        addImageToScene();

        window.addEventListener("resize", onWindowResize);

        renderer.xr.addEventListener('sessionstart', initializeHitTestSource);
      }

      function logStatus(message) {
        logContainer.textContent = message;
        console.log(message);
      }

      function addReticleToScene() {
        const geometry = new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2);
        const material = new THREE.MeshBasicMaterial();
        reticle = new THREE.Mesh(geometry, material);
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add(reticle);
      }

	 const images = [
	 "./assets/Arts/ar1.jpg",
	 "./assets/Arts/ar2.jpg",
	 "./assets/Arts/ar3.jpg"
	 ]; 
	 let currentImageIndex = 0; 
	 let placedImages = []; 
	 
	 function addImageToScene(index) {
	 if (index < images.length) {
		 logStatus("Loading image...");
	 
		 const imageTexture = new THREE.TextureLoader().load(
		 images[index],
		 () => logStatus("Image loaded successfully."),
		 undefined,
		 () => logStatus("Error loading image.")
		 );
	 
		 const imageGeometry = new THREE.PlaneGeometry(1, 1);
		 const imageMaterial = new THREE.MeshBasicMaterial({
		 map: imageTexture,
		 transparent: true,
		 side: THREE.DoubleSide,
		 });
	 
		 const imageMesh = new THREE.Mesh(imageGeometry, imageMaterial);
		 imageMesh.visible = false; 
		 scene.add(imageMesh);
		 
		 placedImages.push(imageMesh); 
	 
		 logStatus("Image added to the scene.");
	 } else {
		 logStatus("No more images to place.");
	 }
	 }
	 
	 function onSelect() {
	 if (hitSomething && reticle.visible) {
		 logStatus(`Placing image ${currentImageIndex + 1}.`);
		 
		 const currentImageMesh = placedImages[currentImageIndex]; // Reference the current image
		 currentImageMesh.position.setFromMatrixPosition(reticle.matrix);
		 
		 const rotation = new THREE.Quaternion().setFromRotationMatrix(reticle.matrix);
		 currentImageMesh.quaternion.copy(rotation);
		 
		 currentImageMesh.visible = true; 
		 reticle.visible = false; 
		 look_for_surface_icon.style.visibility = "hidden"; 
	 
		 currentImageIndex++; 
		 if (currentImageIndex < images.length) {
		 addImageToScene(currentImageIndex); 
		 }
	 } else {
		 logStatus("No surface detected. Move your camera to scan a flat surface.");
	 }
	 }
	 
	 function removeImage(imageMesh) {
	 scene.remove(imageMesh); 
	 logStatus("Image removed.");
	 }
	 
	 function checkForImageRemoval(event) {
	 const raycaster = new THREE.Raycaster();
	 const mouse = new THREE.Vector2();
	 
	 mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
	 mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
	 
	 raycaster.setFromCamera(mouse, camera); 
	 
	 const intersects = raycaster.intersectObjects(placedImages); 
	 
	 if (intersects.length > 0) {
		 removeImage(intersects[0].object); 
	 }
	 }
	 
	 addImageToScene(currentImageIndex);
	 
	 window.addEventListener('click', checkForImageRemoval);

      let hitTestSource = null;
      let localSpace = null;
      let hitTestSourceInitialized = false;

      async function initializeHitTestSource() {
        const session = renderer.xr.getSession();
        if (!session) {
          logStatus("Failed to start AR session.");
          return;
        }

        const viewerSpace = await session.requestReferenceSpace("viewer");
        localSpace = await session.requestReferenceSpace("local");

        try {
          hitTestSource = await session.requestHitTestSource({ space: viewerSpace });
          hitTestSourceInitialized = true;
          logStatus("Hit test source initialized successfully.");
        } catch (error) {
          logStatus("Failed to initialize hit test source.");
          console.error(error);
        }

        session.addEventListener("end", () => {
          isXRSessionStarted = false;
          hitTestSourceInitialized = false;
          hitTestSource = null;
		  close_ar_button.style.visibility = "hidden";
        });
		close_ar_button.style.visibility = "visible";
        logStatus("Looking for a surface...");
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        renderer.setAnimationLoop(render);
      }

	function render(timestamp, frame) {
	if (frame && hitTestSourceInitialized) {
		const hitTestResults = frame.getHitTestResults(hitTestSource);
		if (hitTestResults.length > 0) {
		hitSomething = true;
		const hit = hitTestResults[0];
		const pose = hit.getPose(localSpace);
	
		reticle.visible = true;
		reticle.matrix.fromArray(pose.transform.matrix);
		logStatus("Surface found. Tap to place the image.");
		look_for_surface_icon.style.visibility = "hidden";  
		} else {
		hitSomething = false;
		reticle.visible = true;
		logStatus("Looking for a surface...");
		look_for_surface_icon.style.visibility = "visible"; 
		}
	}
	renderer.render(scene, camera);
	}
    </script>
  </body>
</html>
